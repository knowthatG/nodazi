<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybais.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.kedu.nodazi.mapper.StockMapper">

	<select id="readRecList"
			resultType="CodesDto">
		select R.code
			 , C.company
		  from rec_stock R left outer join codes C
		    on R.code = C.code
		 where r_recdt = #{today}
		   and r_seq = #{seq}
		 limit 1
	</select>
	
	<select id="readRecStock"
			resultType="PricesDto">
		select price_date
			 , price_open
			 , price_close
			 , price_high
			 , price_low
		  from prices
		 where code = lpad(cast(#{code} as char), 6, '0')
		 order by price_date desc
		 limit #{term}
	</select>
	
	<sql id="search">
		<if test="searchType != null">
			<if test="searchType == 'code'.toString()">
				and code like CONCAT('%', #{keyword}, '%')
			</if>
			<if test="searchType == 'com'.toString()">
				and company like CONCAT('%', #{keyword}, '%')
			</if>
		</if>
	</sql>
	
	<select id="searchList"
			resultType="CodesDto">
		<![CDATA[
		select *
		  from codes
		 where id > 0
		]]>
		
		<include refid="search"></include>
		
		 order by id
		 limit #{pageStart}, #{perPageNum}
	</select>
	
	<select id="searchListCount"
			resultType="int">
		<![CDATA[
		select count(id)
		  from codes
		 where id > 0
		   
		]]>
		
		<include refid="search"></include>
	</select>
	
	<select id="readPricePage"
			resultType="PricesDto">
		select *
		  from prices
		 where code = #{code}
		 order by price_date desc
		 limit #{cri.pageStart}, #{cri.perPageNum}
	</select>
	
	<select id="readPriceCount"
			resultType="int">
		select count(id)
		  from prices
		 where code = #{code}
	</select>
	
	<select id="readCodesDto"
			resultType="CodesDto">
		select *
		  from codes
		 where code = #{code}
		   and market_type = 1
	</select>
	
	<select id="readHistoryDto"
			resultType="HistoryDto">
		select h.price_date		as rec_dt
			 , l.price_close	as rec_price
			 , h.price_close	as latest_price
		     , (l.price_close - h.price_close) / h.price_close as variation
		from
		(select price_close
		   from prices
		  where code = #{code}
		  order by price_date desc
		  limit 1
		) as l ,
		(	select price_close
				 , price_date
			  from prices a left join
				(select r_recdt, code
				  from rec_stock
				 where code = #{code}) b
				on a.code = b.code 
			 where a.price_date = b.r_recdt
		) as h
	</select>
	
	<insert id="insertFavor">
		insert into interest_stock( i_seq
								  , u_id
								  , code
		                          , i_regdt
		                          )
						   values ( (select coalesce(max(a.i_seq), 1)
									   from interest_stock a
									)
								  , #{u_id}
								  , #{code}
		                          , curdate()
		                          )
	</insert>
	
	<delete id="deleteFavor">
		delete from interest_stock
		 where u_id = #{u_id}
		   and code = #{code}
	</delete>
	
</mapper>